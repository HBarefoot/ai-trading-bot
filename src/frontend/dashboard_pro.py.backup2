"""
Professional AI Trading Bot Dashboard
Modern dark theme with enhanced visuals and clean layout
"""
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import requests
from datetime import datetime, timedelta
import time
from typing import Optional, Dict, Any

# Page config with dark theme
st.set_page_config(
    page_title="AI Trading Bot Pro",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'About': "AI-Enhanced Trading Bot - Professional Dashboard"
    }
)

# Professional dark theme CSS
st.markdown("""
<style>
    /* Main background and text */
    .stApp {
        background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    }
    
    /* Remove Streamlit branding */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    header {visibility: hidden;}
    
    /* Custom header */
    .header-container {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 2rem;
        border-radius: 15px;
        margin-bottom: 2rem;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .header-title {
        color: white;
        font-size: 2.5rem;
        font-weight: 700;
        text-align: center;
        margin: 0;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .header-subtitle {
        color: rgba(255,255,255,0.9);
        font-size: 1.1rem;
        text-align: center;
        margin-top: 0.5rem;
    }
    
    /* Metric cards */
    .metric-card {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 1.5rem;
        margin: 0.5rem 0;
        height: 140px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
    
    .metric-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        border-color: rgba(102, 126, 234, 0.5);
    }
    
    .metric-label {
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.9rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 0.5rem;
    }
    
    .metric-value {
        color: white;
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 0.3rem;
    }
    
    .metric-delta {
        font-size: 0.9rem;
        font-weight: 600;
    }
    
    .metric-delta.positive {
        color: #10b981;
    }
    
    .metric-delta.negative {
        color: #ef4444;
    }
    
    /* Status badges */
    .status-badge {
        display: inline-block;
        padding: 6px 16px;
        border-radius: 20px;
        font-weight: 600;
        font-size: 0.85rem;
        letter-spacing: 0.5px;
        text-transform: uppercase;
    }
    
    .status-active {
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }
    
    .status-inactive {
        background: linear-gradient(135deg, #f59e0b, #d97706);
        color: white;
        box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
    }
    
    .status-error {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: white;
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }
    
    /* Signal indicators */
    .signal-buy {
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
        padding: 8px 16px;
        border-radius: 10px;
        font-weight: 700;
        display: inline-block;
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }
    
    .signal-sell {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: white;
        padding: 8px 16px;
        border-radius: 10px;
        font-weight: 700;
        display: inline-block;
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }
    
    .signal-hold {
        background: linear-gradient(135deg, #6b7280, #4b5563);
        color: white;
        padding: 8px 16px;
        border-radius: 10px;
        font-weight: 700;
        display: inline-block;
        box-shadow: 0 4px 12px rgba(107, 114, 128, 0.4);
    }
    
    /* Sidebar styling */
    [data-testid="stSidebar"] {
        background: rgba(15, 12, 41, 0.9);
        backdrop-filter: blur(10px);
    }
    
    [data-testid="stSidebar"] .element-container {
        color: white;
    }
    
    /* Tables */
    .dataframe {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        overflow: hidden;
    }
    
    /* Buttons */
    .stButton>button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 0.5rem 2rem;
        font-weight: 600;
        font-size: 1rem;
        transition: all 0.3s ease;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    .stButton>button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
    }
    
    /* Tabs */
    .stTabs [data-baseweb="tab-list"] {
        gap: 8px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        padding: 0.5rem;
    }
    
    .stTabs [data-baseweb="tab"] {
        background: transparent;
        color: rgba(255, 255, 255, 0.7);
        border-radius: 8px;
        font-weight: 600;
        padding: 0.75rem 1.5rem;
        transition: all 0.3s ease;
    }
    
    .stTabs [data-baseweb="tab"]:hover {
        background: rgba(255, 255, 255, 0.1);
        color: white;
    }
    
    .stTabs [aria-selected="true"] {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }
    
    /* Text colors */
    h1, h2, h3, h4, h5, h6, p, span, div {
        color: white !important;
    }
    
    /* Info boxes */
    .stAlert {
        background: rgba(255, 255, 255, 0.05);
        border-left: 4px solid #667eea;
        border-radius: 10px;
    }
    
    /* Expander */
    .streamlit-expanderHeader {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        color: white;
        font-weight: 600;
    }
    
    /* Chart containers */
    .js-plotly-plot {
        border-radius: 15px;
        overflow: hidden;
    }
</style>
""", unsafe_allow_html=True)


class APIClient:
    """API client for backend communication"""
    
    def __init__(self, base_url: str = "http://localhost:9000"):
        self.base_url = base_url
    
    def get(self, endpoint: str, timeout: int = 5) -> Optional[Dict]:
        """GET request with error handling"""
        try:
            response = requests.get(f"{self.base_url}{endpoint}", timeout=timeout)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.ConnectionError:
            return None
        except Exception as e:
            st.error(f"API Error: {str(e)}")
            return None


def render_header():
    """Render professional header"""
    st.markdown("""
        <div class="header-container">
            <h1 class="header-title">ü§ñ AI Trading Bot Pro</h1>
            <p class="header-subtitle">
                AI-Enhanced ‚Ä¢ Real-Time Analysis ‚Ä¢ Professional Trading
            </p>
        </div>
    """, unsafe_allow_html=True)


def render_status_card(status_data: Dict):
    """Render system status card"""
    if not status_data:
        st.error("‚ùå Unable to connect to API")
        return
    
    is_active = status_data.get('trading_engine') == 'active'
    status_class = 'status-active' if is_active else 'status-inactive'
    status_text = 'üü¢ ACTIVE' if is_active else 'üü° INACTIVE'
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">System Status</div>
                <div class="metric-value"><span class="status-badge {status_class}">{status_text}</span></div>
            </div>
        """, unsafe_allow_html=True)
    
    with col2:
        mode = status_data.get('mode', 'UNKNOWN')
        st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">Trading Mode</div>
                <div class="metric-value">{mode}</div>
            </div>
        """, unsafe_allow_html=True)
    
    with col3:
        exchange_status = 'üü¢ Connected' if status_data.get('exchange') == 'connected' else 'üî¥ Disconnected'
        st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">Exchange</div>
                <div class="metric-value">{exchange_status}</div>
            </div>
        """, unsafe_allow_html=True)
    
    with col4:
        feed_status = 'üü¢ Live' if status_data.get('data_feed') == 'active' else 'üî¥ Offline'
        st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">Data Feed</div>
                <div class="metric-value">{feed_status}</div>
            </div>
        """, unsafe_allow_html=True)


def render_portfolio_metrics(portfolio_data: Dict):
    """Render portfolio metrics"""
    if not portfolio_data:
        st.warning("Portfolio data unavailable")
        return
    
    total_value = portfolio_data.get('total_value', 0)
    cash = portfolio_data.get('cash_balance', 0)
    pnl = portfolio_data.get('unrealized_pnl', 0)
    pnl_pct = portfolio_data.get('total_return_pct', 0)
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">Portfolio Value</div>
                <div class="metric-value">${total_value:,.2f}</div>
            </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">Cash Balance</div>
                <div class="metric-value">${cash:,.2f}</div>
            </div>
        """, unsafe_allow_html=True)
    
    with col3:
        delta_class = 'positive' if pnl >= 0 else 'negative'
        delta_sign = '+' if pnl >= 0 else ''
        st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">Unrealized P&L</div>
                <div class="metric-value">${pnl:,.2f}</div>
            </div>
        """, unsafe_allow_html=True)
    
    with col4:
        positions = len(portfolio_data.get('positions', []))
        st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">Open Positions</div>
                <div class="metric-value">{positions}</div>
            </div>
        """, unsafe_allow_html=True)


def render_performance_chart(trades_data: list):
    """Render cumulative P&L chart"""
    if not trades_data:
        st.markdown("""
            <div class="metric-card" style="text-align: center; padding: 3rem;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">üìä</div>
                <div class="metric-label">No Trades Yet</div>
                <div style="color: rgba(255,255,255,0.6); margin-top: 1rem;">
                    Performance chart will appear after your first trade executes.<br>
                    Bot is monitoring market and waiting for optimal entry signal.
                </div>
            </div>
        """, unsafe_allow_html=True)
        return
    
    df = pd.DataFrame(trades_data)
    if 'exit_time' in df.columns and 'profit' in df.columns:
        df['exit_time'] = pd.to_datetime(df['exit_time'])
        df = df.sort_values('exit_time')
        df['cumulative_pnl'] = df['profit'].cumsum()
        
        fig = go.Figure()
        
        # Add cumulative P&L line
        fig.add_trace(go.Scatter(
            x=df['exit_time'],
            y=df['cumulative_pnl'],
            mode='lines+markers',
            name='Cumulative P&L',
            line=dict(color='#10b981', width=3),
            marker=dict(size=8, color='#10b981'),
            fill='tozeroy',
            fillcolor='rgba(16, 185, 129, 0.1)'
        ))
        
        # Add zero line
        fig.add_hline(y=0, line_dash="dash", line_color="rgba(255,255,255,0.3)")
        
        fig.update_layout(
            title="Cumulative Performance",
            xaxis_title="Date",
            yaxis_title="Profit/Loss ($)",
            template="plotly_dark",
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(color='white'),
            hovermode='x unified',
            showlegend=False
        )
        
        st.plotly_chart(fig, use_container_width=True)


def render_signals_table(signals_data: Dict):
    """Render signals in a professional table"""
    if not signals_data or not signals_data.get('signals'):
        st.markdown("""
            <div class="metric-card" style="text-align: center; padding: 3rem;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">üîç</div>
                <div class="metric-label">Monitoring Market</div>
                <div style="color: rgba(255,255,255,0.6); margin-top: 1rem;">
                    AI is analyzing market data every 30 seconds.<br>
                    Signals will appear when conditions align.
                </div>
            </div>
        """, unsafe_allow_html=True)
        return
    
    signals = signals_data['signals']
    df = pd.DataFrame(signals)
    
    # Format the display
    if not df.empty:
        # Add signal badges
        def format_signal(signal_type):
            if signal_type == 'BUY':
                return 'üü¢ BUY'
            elif signal_type == 'SELL':
                return 'üî¥ SELL'
            else:
                return '‚ö™ HOLD'
        
        df['Signal'] = df['signal_type'].apply(format_signal)
        df['Price'] = df['price'].apply(lambda x: f"${x:,.2f}")
        df['RSI'] = df['rsi'].apply(lambda x: f"{x:.1f}" if pd.notna(x) else 'N/A')
        
        # Display table
        display_df = df[['symbol', 'Signal', 'Price', 'RSI', 'trend']].rename(columns={
            'symbol': 'Symbol',
            'trend': 'Trend'
        })
        
        st.dataframe(display_df, use_container_width=True, hide_index=True)


def render_price_charts(api: 'APIClient'):
    """Render live price chart with symbol selector"""
    
    # Symbol selector
    symbol_options = {
        'BTC/USDT': 'BTCUSDT',
        'ETH/USDT': 'ETHUSDT',
        'SOL/USDT': 'SOLUSDT'
    }
    
    col1, col2 = st.columns([1, 3])
    with col1:
        selected_display = st.selectbox(
            "Select Symbol",
            options=list(symbol_options.keys()),
            index=0
        )
    
    symbol = symbol_options[selected_display]
    
    # Fetch historical data from API
    try:
        response = requests.get(f'http://localhost:9000/api/candles/{symbol}?limit=100', timeout=5)
        if response.status_code == 200:
            data = response.json()
            
            if data and len(data) > 0:
                df = pd.DataFrame(data)
                
                # Create candlestick chart
                fig = go.Figure(data=[go.Candlestick(
                    x=df['timestamp'],
                    open=df['open'],
                    high=df['high'],
                    low=df['low'],
                    close=df['close'],
                    increasing_line_color='#10b981',
                    decreasing_line_color='#ef4444',
                    name=selected_display
                )])
                
                # Overlay trades on the chart
                try:
                    trades_response = requests.get('http://localhost:9000/api/trades?limit=50', timeout=3)
                    if trades_response.status_code == 200:
                        all_trades = trades_response.json()
                        # Filter trades for this symbol
                        symbol_trades = [t for t in all_trades if t.get('symbol') == symbol]
                        
                        if symbol_trades:
                            # Add entry points (BUY)
                            entry_times = [t['entry_time'] for t in symbol_trades]
                            entry_prices = [t['entry_price'] for t in symbol_trades]
                            
                            fig.add_trace(go.Scatter(
                                x=entry_times,
                                y=entry_prices,
                                mode='markers',
                                name='Entry',
                                marker=dict(
                                    symbol='triangle-up',
                                    size=15,
                                    color='#10b981',
                                    line=dict(color='white', width=2)
                                ),
                                hovertemplate='<b>ENTRY</b><br>Price: $%{y:,.2f}<br>Time: %{x}<extra></extra>'
                            ))
                            
                            # Add exit points and stop loss / take profit lines
                            for trade in symbol_trades:
                                if trade.get('exit_price'):
                                    # Exit point (SELL)
                                    exit_color = '#10b981' if trade.get('profit', 0) > 0 else '#ef4444'
                                    fig.add_trace(go.Scatter(
                                        x=[trade['exit_time']],
                                        y=[trade['exit_price']],
                                        mode='markers',
                                        name='Exit',
                                        marker=dict(
                                            symbol='triangle-down',
                                            size=15,
                                            color=exit_color,
                                            line=dict(color='white', width=2)
                                        ),
                                        hovertemplate=f"<b>EXIT</b><br>Price: ${trade['exit_price']:,.2f}<br>P&L: ${trade.get('profit', 0):,.2f}<extra></extra>",
                                        showlegend=False
                                    ))
                                
                                # Stop loss line
                                if trade.get('stop_loss'):
                                    fig.add_shape(
                                        type="line",
                                        x0=trade['entry_time'],
                                        x1=trade.get('exit_time', df['timestamp'].iloc[-1]),
                                        y0=trade['stop_loss'],
                                        y1=trade['stop_loss'],
                                        line=dict(color='#ef4444', width=1, dash='dash'),
                                        name='Stop Loss'
                                    )
                                
                                # Take profit line
                                if trade.get('take_profit'):
                                    fig.add_shape(
                                        type="line",
                                        x0=trade['entry_time'],
                                        x1=trade.get('exit_time', df['timestamp'].iloc[-1]),
                                        y0=trade['take_profit'],
                                        y1=trade['take_profit'],
                                        line=dict(color='#10b981', width=1, dash='dash'),
                                        name='Take Profit'
                                    )
                except Exception as trade_err:
                    pass  # Silently skip if trades can't be overlaid
                
                # Update layout for dark theme
                fig.update_layout(
                    title=dict(
                        text=f'{selected_display} - 5 Minute Chart',
                        font=dict(color='white', size=20),
                        x=0.5,
                        xanchor='center'
                    ),
                    template='plotly_dark',
                    height=600,
                    margin=dict(l=0, r=0, t=60, b=0),
                    xaxis_title="Time",
                    yaxis_title="Price (USDT)",
                    paper_bgcolor='rgba(0,0,0,0)',
                    plot_bgcolor='rgba(0,0,0,0)',
                    font=dict(color='white'),
                    xaxis=dict(
                        gridcolor='rgba(255,255,255,0.1)',
                        showgrid=True,
                        rangeslider=dict(visible=False)
                    ),
                    yaxis=dict(
                        gridcolor='rgba(255,255,255,0.1)',
                        showgrid=True
                    ),
                    hovermode='x unified',
                    showlegend=True,
                    legend=dict(
                        bgcolor='rgba(0,0,0,0.5)',
                        font=dict(color='white')
                    )
                )
                
                st.plotly_chart(fig, use_container_width=True)
                
                # Show current price info
                latest = df.iloc[-1]
                col1, col2, col3, col4 = st.columns(4)
                
                price_change = latest['close'] - latest['open']
                price_change_pct = (price_change / latest['open'] * 100) if latest['open'] > 0 else 0
                change_color = '#10b981' if price_change >= 0 else '#ef4444'
                
                with col1:
                    st.markdown(f"""
                        <div class="metric-card">
                            <div class="metric-label">Last Price</div>
                            <div class="metric-value">${latest['close']:,.2f}</div>
                        </div>
                    """, unsafe_allow_html=True)
                
                with col2:
                    st.markdown(f"""
                        <div class="metric-card">
                            <div class="metric-label">24h Change</div>
                            <div class="metric-value" style="color: {change_color};">
                                {'+' if price_change >= 0 else ''}{price_change_pct:.2f}%
                            </div>
                        </div>
                    """, unsafe_allow_html=True)
                
                with col3:
                    st.markdown(f"""
                        <div class="metric-card">
                            <div class="metric-label">High</div>
                            <div class="metric-value">${latest['high']:,.2f}</div>
                        </div>
                    """, unsafe_allow_html=True)
                
                with col4:
                    st.markdown(f"""
                        <div class="metric-card">
                            <div class="metric-label">Low</div>
                            <div class="metric-value">${latest['low']:,.2f}</div>
                        </div>
                    """, unsafe_allow_html=True)
                
            else:
                st.markdown("""
                    <div class="metric-card" style="text-align: center; padding: 3rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">‚è≥</div>
                        <div class="metric-label">Building Price History</div>
                        <div style="color: rgba(255,255,255,0.6); margin-top: 1rem;">
                            System is accumulating 5-minute candle data from Binance.US<br>
                            Chart will appear after 10-15 minutes of data collection.
                        </div>
                    </div>
                """, unsafe_allow_html=True)
        else:
            st.warning(f"Could not fetch data for {symbol}")
    except Exception as e:
        st.error(f"Error loading chart: {str(e)}")


def render_trades_table(trades_data: list):
    """Render recent trades"""
    if not trades_data:
        st.markdown("""
            <div class="metric-card" style="text-align: center; padding: 3rem;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">üìã</div>
                <div class="metric-label">No Trades Yet</div>
                <div style="color: rgba(255,255,255,0.6); margin-top: 1rem;">
                    Trade history will appear here after first execution.<br>
                    Expected: 3-7 days for first trade (high-probability setups only).
                </div>
            </div>
        """, unsafe_allow_html=True)
        return
    
    df = pd.DataFrame(trades_data)
    
    if not df.empty:
        # Format columns
        df['Entry'] = df['entry_price'].apply(lambda x: f"${x:,.2f}")
        df['Exit'] = df['exit_price'].apply(lambda x: f"${x:,.2f}" if pd.notna(x) else 'Open')
        df['P&L'] = df['profit'].apply(lambda x: f"${x:,.2f}" if pd.notna(x) else '-')
        df['P&L %'] = df['profit_pct'].apply(lambda x: f"{x:.2f}%" if pd.notna(x) else '-')
        
        # Select columns to display
        display_df = df[['symbol', 'side', 'Entry', 'Exit', 'P&L', 'P&L %', 'entry_time']].rename(columns={
            'symbol': 'Symbol',
            'side': 'Side',
            'entry_time': 'Time'
        })
        
        st.dataframe(display_df.tail(20), use_container_width=True, hide_index=True)


def main():
    """Main dashboard"""
    api = APIClient()
    
    # Render header
    render_header()
    
    # Sidebar controls
    with st.sidebar:
        st.markdown("### üéõÔ∏è Dashboard Controls")
        
        # Engine control buttons
        status_check = api.get('/api/status')
        is_running = status_check and status_check.get('trading_engine') == 'active'
        
        col1, col2 = st.columns(2)
        with col1:
            if st.button("‚ñ∂Ô∏è Start", use_container_width=True, disabled=is_running):
                try:
                    response = requests.post('http://localhost:9000/api/trading/start', timeout=5)
                    if response.status_code == 200:
                        st.success("Engine started!")
                        time.sleep(1)
                        st.rerun()
                    else:
                        st.error("Failed to start")
                except:
                    st.error("API not responding")
        
        with col2:
            if st.button("‚è∏Ô∏è Stop", use_container_width=True, disabled=not is_running):
                try:
                    response = requests.post('http://localhost:9000/api/trading/stop', timeout=5)
                    if response.status_code == 200:
                        st.success("Engine stopped!")
                        time.sleep(1)
                        st.rerun()
                    else:
                        st.error("Failed to stop")
                except:
                    st.error("API not responding")
        
        st.markdown("---")
        
        if st.button("üîÑ Refresh Data", use_container_width=True):
            st.rerun()
        
        auto_refresh = st.checkbox("Auto-refresh (30s)", value=False)
        
        if auto_refresh:
            time.sleep(30)
            st.rerun()
        
        st.markdown("---")
        st.markdown("### üìä System Info")
        st.caption("API: http://localhost:9000")
        st.caption(f"Updated: {datetime.now().strftime('%H:%M:%S')}")
    
    # Fetch data
    status_data = api.get('/api/status')
    portfolio_data = api.get('/api/portfolio')
    signals_data = api.get('/api/signals')
    trades_data = api.get('/api/trades?limit=50')
    
    # Status cards
    render_status_card(status_data)
    
    st.markdown("<br>", unsafe_allow_html=True)
    
    # Portfolio metrics
    render_portfolio_metrics(portfolio_data)
    
    st.markdown("<br>", unsafe_allow_html=True)
    
    # Tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["üìä Overview", "üìà Charts", "üíπ Signals", "üìã Trades", "üíº Portfolio"])
    
    with tab1:
        st.markdown("### üìà Performance Overview")
        
        # Show monitoring status if no trades
        if not trades_data:
            st.markdown("""
                <div class="metric-card" style="margin-bottom: 2rem;">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="font-size: 2rem;">üéØ</div>
                        <div>
                            <div class="metric-label">System Status</div>
                            <div style="color: white; font-size: 1.2rem; margin-top: 0.5rem;">
                                ‚úÖ Bot is actively monitoring market (every 30s)
                            </div>
                            <div style="color: rgba(255,255,255,0.6); margin-top: 0.5rem; font-size: 0.9rem;">
                                Waiting for: Technical (40%) + LSTM (30%) + Sentiment (30%) alignment > 0.6
                            </div>
                        </div>
                    </div>
                </div>
            """, unsafe_allow_html=True)
        
        render_performance_chart(trades_data if trades_data else [])
        
        col1, col2 = st.columns(2)
        
        with col1:
            if trades_data:
                df = pd.DataFrame(trades_data)
                winning = len(df[df['profit'] > 0])
                total = len(df)
                win_rate = (winning / total * 100) if total > 0 else 0
                
                st.markdown(f"""
                    <div class="metric-card">
                        <div class="metric-label">Win Rate</div>
                        <div class="metric-value">{win_rate:.1f}%</div>
                        <div class="metric-delta">({winning}/{total} trades)</div>
                    </div>
                """, unsafe_allow_html=True)
        
        with col2:
            if trades_data:
                df = pd.DataFrame(trades_data)
                total_profit = df['profit'].sum()
                
                delta_class = 'positive' if total_profit >= 0 else 'negative'
                st.markdown(f"""
                    <div class="metric-card">
                        <div class="metric-label">Total Realized P&L</div>
                        <div class="metric-value">${total_profit:,.2f}</div>
                    </div>
                """, unsafe_allow_html=True)
    
    with tab2:
        st.markdown("### üìà Live Price Charts")
        render_price_charts(api)
    
    with tab3:
        st.markdown("### üíπ Current Signals")
        render_signals_table(signals_data)
    
    with tab4:
        st.markdown("### üìã Trade History")
        render_trades_table(trades_data if trades_data else [])
    
    with tab5:
        st.markdown("### üíº Portfolio Details")
        if portfolio_data and portfolio_data.get('positions'):
            positions_df = pd.DataFrame(portfolio_data['positions'])
            st.dataframe(positions_df, use_container_width=True, hide_index=True)
        else:
            st.info("No open positions")


if __name__ == "__main__":
    main()
